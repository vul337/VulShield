/*  
*  rsa-verify.c - using crypto api to verify digital signature.
*/
#include <linux/module.h>
#include <linux/kernel.h>   
#include <crypto/public_key.h>
#include <crypto/akcipher.h>
#include <linux/scatterlist.h>
#include <crypto/hash.h>
MODULE_LICENSE("GPL");
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/types.h>
#include <linux/string.h>
#include <net/genetlink.h>
#include "../include/protocol.h"

struct sdesc {
    struct shash_desc shash;
    char ctx[];
};

static struct sdesc *init_sdesc(struct crypto_shash *alg)
{
    struct sdesc *sdesc;
    int size;

    size = sizeof(struct shash_desc) + crypto_shash_descsize(alg);
    sdesc = kmalloc(size, GFP_KERNEL);
    if (!sdesc)
        return ERR_PTR(-ENOMEM);
    sdesc->shash.tfm = alg;
    return sdesc;
}

static int calc_hash(struct crypto_shash *alg,
             const unsigned char *data, unsigned int datalen,
             unsigned char *digest)
{
    struct sdesc *sdesc;
    int ret;

    sdesc = init_sdesc(alg);
    if (IS_ERR(sdesc)) {
        pr_info("can't alloc sdesc\n");
        return PTR_ERR(sdesc);
    }

    ret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);
    kfree(sdesc);
    return ret;
}

static int do_sha256(const unsigned char *data, unsigned char *out_digest)
{
    struct crypto_shash *alg;
    char *hash_alg_name = "sha256";
    unsigned int datalen = strlen(data); // remove the null byte

    alg = crypto_alloc_shash(hash_alg_name, 0, 0);
    if(IS_ERR(alg)){
        pr_info("can't alloc alg %s\n", hash_alg_name);
        return PTR_ERR(alg);
    }
    calc_hash(alg, data, datalen, out_digest);

    // Very dirty print of 8 first bytes for comparaison with sha256sum
    printk(KERN_INFO "HASH(%s, %i): %02x%02x%02x%02x%02x%02x%02x%02x\n",
          data, datalen, out_digest[0], out_digest[1], out_digest[2], out_digest[3], out_digest[4], 
          out_digest[5], out_digest[6], out_digest[7]);

    crypto_free_shash(alg);
    return 0;
}

int public_key_verify_signature1(const struct public_key *pkey,
                const struct public_key_signature *sig)
{
    struct crypto_wait cwait;
    struct crypto_akcipher *tfm;
    struct akcipher_request *req;
    struct scatterlist src_tab[3];
    const char *alg_name;
    char alg_name_buf[CRYPTO_MAX_ALG_NAME];
    void *output;
    unsigned int outlen;
    int ret;

    pr_devel("==>%s()\n", __func__);

    BUG_ON(!pkey);
    BUG_ON(!sig);
    BUG_ON(!sig->s);

    if (!sig->digest)
        return -ENOPKG;

    alg_name = sig->pkey_algo;
    if (strcmp(sig->pkey_algo, "rsa") == 0) {
        /* The data wangled by the RSA algorithm is typically padded
         * and encoded in some manner, such as EMSA-PKCS1-1_5 [RFC3447
         * sec 8.2].
         */
        if (snprintf(alg_name_buf, CRYPTO_MAX_ALG_NAME,
                 "pkcs1pad(rsa,%s)", sig->hash_algo
                 ) >= CRYPTO_MAX_ALG_NAME)
            return -EINVAL;
        alg_name = alg_name_buf;
    }

    tfm = crypto_alloc_akcipher(alg_name, 0, 0);
    if (IS_ERR(tfm))
        return PTR_ERR(tfm);

    ret = -ENOMEM;
    req = akcipher_request_alloc(tfm, GFP_KERNEL);
    if (!req)
        goto error_free_tfm;

    ret = crypto_akcipher_set_pub_key(tfm, pkey->key, pkey->keylen);
    if (ret)
        goto error_free_req;

    ret = -ENOMEM;
    outlen = crypto_akcipher_maxsize(tfm);
    output = kmalloc(outlen, GFP_KERNEL);
    if (!output)
        goto error_free_req;


    sg_init_table(src_tab, 3);

    sg_set_buf(&src_tab[1], sig->digest, sig->digest_size);
    sg_set_buf(&src_tab[0], sig->s, sig->s_size);

    akcipher_request_set_crypt(req, src_tab, NULL, sig->s_size, sig->digest_size);

    crypto_init_wait(&cwait);
    akcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |
                      CRYPTO_TFM_REQ_MAY_SLEEP,
                      crypto_req_done, &cwait);


    ret = crypto_wait_req(crypto_akcipher_verify(req), &cwait);
    if (ret)
        goto out_free_output;
    pr_info("signature verified successfuly!!!\n");

out_free_output:
    kfree(output);
error_free_req:
    akcipher_request_free(req);
error_free_tfm:
    crypto_free_akcipher(tfm);
    pr_devel("<==%s() = %d\n", __func__, ret);
    if (WARN_ON_ONCE(ret > 0))
        ret = -EINVAL;
    return ret;
}

unsigned char public_key_bytes[] = {0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xaa, 0xd1, 0x3f, 0x5b, 0xa3, 0x79, 0x1f,0x56, 0xa0, 0x3f, 0x81, 0xb4, 0x44, 0xe5, 0x26, 0xde, 0xd8, 0x8b, 0xf4, 0x14, 0x49, 0x99, 0xa9,0xfd, 0x96, 0x5d, 0xc1, 0xd6, 0x95, 0xef, 0xc4, 0x8e, 0xe4, 0xf7, 0xe5, 0x7e, 0x81, 0x80, 0x48,0x06, 0x2b, 0xfd, 0x49, 0x94, 0x3e, 0x16, 0xc2, 0x2a, 0x29, 0xed, 0xae, 0x72, 0x9b, 0x22, 0x1d,0xc9, 0x50, 0x4e, 0x53, 0x8e, 0x9e, 0x82, 0x98, 0x08, 0x8b, 0xf3, 0xe8, 0x87, 0x9d, 0x51, 0xf5,0xcd, 0xee, 0x4d, 0xeb, 0xef, 0x40, 0xc7, 0xf2, 0x5f, 0x19, 0xb2, 0x7f, 0x21, 0x10, 0x19, 0xeb,0xfd, 0x7f, 0xc6, 0x66, 0xe8, 0x7c, 0x75, 0x20, 0x0d, 0x84, 0x2c, 0x89, 0x4e, 0x52, 0x80, 0x5d,0xfd, 0xc9, 0xb8, 0x03, 0x0e, 0x5d, 0xa2, 0x94, 0x2a, 0x04, 0x5a, 0x3b, 0x82, 0xcc, 0x97, 0x56,0xef, 0xa0, 0x0a, 0x76, 0xf7, 0x04, 0xbe, 0x06, 0xa5, 0xfc, 0x8b, 0xe1, 0x1f, 0x8b, 0xc2, 0xa6,0x56, 0x39, 0xe9, 0x01, 0x4d, 0x2d, 0x11, 0x57, 0x52, 0x47, 0xdd, 0xf8, 0x47, 0x5e, 0xe6, 0x43,0x75, 0xe8, 0x6d, 0x15, 0xa5, 0x90, 0x30, 0xd5, 0xa9, 0xb7, 0xbd, 0x07, 0x10, 0xaa, 0x82, 0x5d,0xb2, 0xc4, 0x73, 0x25, 0xd3, 0x7d, 0x96, 0x3d, 0x84, 0x74, 0x3d, 0x72, 0x08, 0x94, 0x2c, 0xbb,0xbe, 0xa5, 0xde, 0xc0, 0xc0, 0x3c, 0x93, 0x3d, 0x94, 0xf4, 0x25, 0xc5, 0xef, 0xee, 0x48, 0x1d,0xb3, 0x3d, 0x10, 0xaa, 0xe5, 0x75, 0xbe, 0xc2, 0x0c, 0x25, 0x4c, 0x7a, 0xa5, 0xe0, 0x94, 0xb9,0x3f, 0x5a, 0x13, 0x48, 0xdc, 0x52, 0x08, 0x6a, 0x75, 0xa2, 0x1b, 0x91, 0x28, 0xb2, 0x7d, 0xe3,0x4d, 0xdc, 0x82, 0x98, 0x01, 0x05, 0xf4, 0xdf, 0x47, 0x51, 0x8c, 0xa7, 0xea, 0x03, 0xff, 0x63,0x9b, 0xe5, 0xe5, 0xe0, 0x69, 0x6c, 0x02, 0x12, 0xa1, 0x02, 0x03, 0x01, 0x00, 0x01};

int rsa_verify(char *policy,char *signature)
{       
    // u8 signature_bytes[]... if it was here - it would work
 // u8 signature_bytes[]... if it was here - it would work
//public key in der format

    //SHA-256 digest for the data "asaf"
//    unsigned char digest[] = { 0x6f,0x82,0xd3,0x9a,0x2c,0x53,0xaf,0xa5,0x00,0xd4,0x6e,0x0e,0xfb,0xe1,0xa8,0xd5,0x6c,0xc4,0x69,0x4d,0xde,0x94,0x66,0xde,0xb2,0xb7,0x76,0x30,0xd1,0xf7,0x53,0x57 };
unsigned char *digest=kmalloc(256, GFP_KERNEL);
if(digest < 0) return -ENOMEM;
//do_sha256("asaf", digest);
// do_sha256("dora",digest);
do_sha256(policy,digest);
//given signature of data "asaf" using a private key
//unsigned char signature_bytes[] = { 0xb7,0xa8,0x48,0x1c,0x31,0x80,0xab,0xa3,0x16,0x23,0xc8,0xb8,0x2b,0xf6,0x99,0x5b,0x90,0x64,0xe1,0x4f,0xda,0xe4,0xfc,0x4c,0xa4,0xbe,0x58,0x9c,0xec,0xef,0x9c,0x92,0x56,0x05,0x3e,0xa3,0xcc,0x00,0xd3,0x7e,0xa3,0xab,0x09,0xd7,0xc9,0x3f,0x2b,0x28,0x4f,0x14,0x57,0x2a,0x24,0x56,0x07,0x55,0xc1,0xbe,0xf8,0xbe,0x41,0x8d,0xa3,0xa4,0x79,0xdd,0x27,0x3e,0xc6,0x32,0xe1,0x80,0xe3,0x40,0x27,0x48,0x9f,0xe8,0xb6,0x87,0xee,0x4e,0x8a,0x82,0x6c,0x6c,0x32,0x50,0x7a,0x28,0x63,0xbc,0xb2,0xd4,0x59,0x50,0x66,0x07,0xb9,0x93,0x27,0x1b,0x45,0x35,0x00,0x15,0xe2,0x6e,0x7d,0xf8,0xb6,0x75,0x9b,0x3a,0xb8,0xc5,0xe5,0x1d,0xda,0x4c,0xdc,0x01,0xb2,0x69,0x7f,0x87,0x08,0x6e,0x11,0xb7,0xcd,0x1f,0x9f,0xaa,0xb4,0xe4,0x13,0x4e,0x67,0x1f,0x60,0x9c,0x30,0x7d,0xec,0xf1,0xf4,0x0d,0x72,0x62,0x39,0x51,0x82,0x9f,0x5f,0x25,0x1f,0x4a,0xff,0x73,0x88,0xf1,0x8e,0x2d,0x6e,0xec,0xa9,0x2a,0xea,0xca,0x49,0x39,0x6d,0x00,0xeb,0xb8,0x25,0x2b,0x02,0x06,0xcf,0xf3,0xa7,0xe2,0x14,0xcd,0xd6,0x5c,0xfa,0xd0,0x87,0x6b,0x29,0xc5,0xc4,0xe0,0x97,0x76,0x6b,0xd8,0x7c,0x49,0x63,0x2e,0xc9,0x96,0xf6,0xb2,0x3b,0x2d,0x35,0x77,0x3c,0x33,0x09,0x39,0xa6,0xff,0xb2,0x98,0x27,0x61,0x32,0x5b,0x30,0x30,0xd5,0xee,0xa0,0xcb,0x0a,0xb1,0xc7,0x6d,0x7b,0xf5,0x1a,0x12,0x25,0xe1,0xf0,0x78,0x4f,0xd9,0x54,0x32,0xb7,0x3b,0x6f,0xf3,0x33,0x9e,0xa8,0x58,0x7c,0xa3 };
    
    // unsigned char signature_bytes[] = {0x85,0x9f,0x14,0x66,0x96,0x2c,0xec,0xd7,0x0e,0xb7,0xbe,0x9f,0xec,0x01,0x60,0x2f,0xd4,0x6b,0x53,0x11,0xd1,0x6a,0x19,0x4f,0x10,0x67,0x8e,0x0a,0xfe,0x8b,0x03,0x22,0x99,0x52,0x7e,0x4f,0xb1,0x86,0xa6,0x35,0x74,0xcc,0xfa,0xcb,0x93,0x95,0x43,0xca,0x3e,0x42,0x7e,0x3a,0x89,0x99,0x5c,0xb8,0x40,0x94,0x07,0xf0,0xd4,0xa2,0xcf,0xe1,0xd6,0xd4,0xa1,0xe5,0xce,0xce,0x5e,0x75,0x5e,0xee,0x1d,0x73,0xbb,0x56,0x4d,0x8e,0xf6,0xe3,0xc9,0xd9,0x22,0x69,0x76,0x38,0x58,0x1f,0x5a,0xa3,0x53,0xb9,0xfc,0x40,0x81,0x15,0x7b,0x3a,0x52,0xa5,0xb8,0x52,0x6c,0x8b,0xf9,0xc1,0x9d,0x5f,0xa9,0xef,0x87,0x10,0x92,0x6f,0xf2,0x59,0x8e,0xf0,0x5e,0xea,0x31,0xc5,0x4b,0x6c,0xe4,0xd9,0x43,0x66,0x28,0x32,0xec,0x6b,0x85,0x7f,0x66,0x7d,0xdb,0x51,0xc9,0x31,0x70,0x56,0x70,0xb8,0x7d,0x79,0x37,0x1c,0x05,0xac,0x18,0xf3,0xef,0x06,0x25,0x28,0xe9,0xa6,0xfd,0x30,0x0c,0xb3,0x91,0x86,0x3e,0xc4,0xad,0xd6,0xb3,0xce,0xef,0x2c,0xf6,0xd1,0xdb,0x59,0xe5,0x17,0x1d,0x64,0x1e,0x30,0xeb,0x7c,0x07,0x4c,0x3c,0x2b,0x46,0xc7,0xf6,0xc3,0xbc,0xc4,0x06,0xca,0x57,0x90,0x63,0x09,0xe3,0xe0,0x2a,0xe4,0xfb,0x53,0x5c,0x3b,0xc6,0xe2,0xd7,0xa7,0x84,0xf6,0xa4,0xca,0x90,0xc5,0x34,0xf5,0x7d,0x47,0xb4,0x9a,0x4d,0x67,0x78,0x74,0xb3,0x24,0xe4,0x27,0xd4,0x19,0xbc,0x7a,0x5d,0x93,0x12,0x16,0x41,0xc3,0x94,0xde,0xdd,0xc1,0x8b,0x54,0xf1,0x15,0xbe,0x53,0x60,0x2f};
    
    struct public_key rsa_pub_key = {
        .key = public_key_bytes,
        .keylen = 270,
        .pkey_algo = "rsa",
        .id_type = "X509"
    };

    struct public_key_signature sig = {
        // .s = signature_bytes,
        .s = signature,
        .s_size = 256,
        .digest = digest,
        .digest_size = 32,
        .pkey_algo = "rsa",
        .hash_algo = "sha256"
    };

    int error = public_key_verify_signature1(&rsa_pub_key, &sig);
    if (error) {
        pr_info("error verifying. error %d\n", error);
        return -1;
    }

    pr_info("signature verified successfuly!!!\n");   
    return 0;
}

int verify(struct genl_info *info){
	int di = 1;
    size_t max_digits = 20;  /* each u64 <= 20 bits */
    unsigned char* path = (unsigned char *)nla_data(info->attrs[DI_FILE]);
    unsigned char* sig = (unsigned char *)nla_data(info->attrs[DI_HASH_DETECT]);
    size_t path_len = strlen(path);
    size_t total_len;
    char *result, *p;
    int written;
    total_len = (DI_MAX-2) * max_digits + path_len + 1;
    result = kmalloc(total_len, GFP_KERNEL);
    if (!result)
        return NULL;
    int sig_len=nla_len(info->attrs[DI_HASH_DETECT]);
    if(sig_len!=256){
        pr_err("the length of sig is: %d\n", sig_len);
        pr_err("[VUL_PATCH] Invalid signature: the length of signature is error!\n");
        return -EINVAL;
    }

    p = result;
	for(; di != DI_MAX; di++ ){
        if (!info->attrs[di]) {
			pr_err("[VUL_PATCH] Invalid request: Missing symbol attribute: %d.\n", di);
			return -EINVAL;
		}
        if (di==DI_HASH_DETECT) {
            // pr_err("sig is %s.\n", sig);
            continue;//skip the sig
        }
        if (di==DI_FILE){
            // pr_err("p is %s.\n", path);
            written = sprintf(p, "%s", path);
            p += written;
        }
        else{
            // pr_err("p is : %llu\n", nla_get_u64(info->attrs[di]));
            written = sprintf(p, "%llu", nla_get_u64(info->attrs[di]));
            p += written;
        }
	}
    pr_err("the policy is: %s\n", result);
    int ret=rsa_verify(result,sig);
    if(ret!=0){
        pr_err("[VUL_PATCH] Error verifying.\n");
        return -EINVAL;
    }
	return 0;
}

